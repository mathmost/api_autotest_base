{"name": "test_login_session", "status": "broken", "statusDetails": {"message": "kombu.exceptions.OperationalError: Error 10061 connecting to 127.0.0.1:6379. 由于目标计算机积极拒绝，无法连接。.", "trace": "self = Connection<host=127.0.0.1,port=6379,db=0>\n\n    def connect(self):\n        \"Connects to the Redis server if not already connected\"\n        if self._sock:\n            return\n        try:\n>           sock = self._connect()\n\nC:\\Users\\luban\\AppData\\Local\\Programs\\Python\\Python37\\lib\\site-packages\\redis\\connection.py:559: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Connection<host=127.0.0.1,port=6379,db=0>\n\n    def _connect(self):\n        \"Create a TCP socket connection\"\n        # we want to mimic what socket.create_connection does to support\n        # ipv4/ipv6, but we want to set options prior to calling\n        # socket.connect()\n        err = None\n        for res in socket.getaddrinfo(self.host, self.port, self.socket_type,\n                                      socket.SOCK_STREAM):\n            family, socktype, proto, canonname, socket_address = res\n            sock = None\n            try:\n                sock = socket.socket(family, socktype, proto)\n                # TCP_NODELAY\n                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n    \n                # TCP_KEEPALIVE\n                if self.socket_keepalive:\n                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n                    for k, v in iteritems(self.socket_keepalive_options):\n                        sock.setsockopt(socket.IPPROTO_TCP, k, v)\n    \n                # set the socket_connect_timeout before we connect\n                sock.settimeout(self.socket_connect_timeout)\n    \n                # connect\n                sock.connect(socket_address)\n    \n                # set the socket_timeout now that we're connected\n                sock.settimeout(self.socket_timeout)\n                return sock\n    \n            except socket.error as _:\n                err = _\n                if sock is not None:\n                    sock.close()\n    \n        if err is not None:\n>           raise err\n\nC:\\Users\\luban\\AppData\\Local\\Programs\\Python\\Python37\\lib\\site-packages\\redis\\connection.py:615: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Connection<host=127.0.0.1,port=6379,db=0>\n\n    def _connect(self):\n        \"Create a TCP socket connection\"\n        # we want to mimic what socket.create_connection does to support\n        # ipv4/ipv6, but we want to set options prior to calling\n        # socket.connect()\n        err = None\n        for res in socket.getaddrinfo(self.host, self.port, self.socket_type,\n                                      socket.SOCK_STREAM):\n            family, socktype, proto, canonname, socket_address = res\n            sock = None\n            try:\n                sock = socket.socket(family, socktype, proto)\n                # TCP_NODELAY\n                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n    \n                # TCP_KEEPALIVE\n                if self.socket_keepalive:\n                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n                    for k, v in iteritems(self.socket_keepalive_options):\n                        sock.setsockopt(socket.IPPROTO_TCP, k, v)\n    \n                # set the socket_connect_timeout before we connect\n                sock.settimeout(self.socket_connect_timeout)\n    \n                # connect\n>               sock.connect(socket_address)\nE               ConnectionRefusedError: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\n\nC:\\Users\\luban\\AppData\\Local\\Programs\\Python\\Python37\\lib\\site-packages\\redis\\connection.py:603: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <celery.backends.redis.ResultConsumer object at 0x00000213B26A1C50>\n\n    @contextmanager\n    def reconnect_on_error(self):\n        try:\n>           yield\n\nC:\\Users\\luban\\AppData\\Local\\Programs\\Python\\Python37\\lib\\site-packages\\celery\\backends\\redis.py:117: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <celery.backends.redis.ResultConsumer object at 0x00000213B26A1C50>\ntask_id = '2fddb8fe-e872-4a73-ad78-6218c609c79b'\n\n    def _consume_from(self, task_id):\n        key = self._get_key_for_task(task_id)\n        if key not in self.subscribed_to:\n            self.subscribed_to.add(key)\n            with self.reconnect_on_error():\n>               self._pubsub.subscribe(key)\n\nC:\\Users\\luban\\AppData\\Local\\Programs\\Python\\Python37\\lib\\site-packages\\celery\\backends\\redis.py:167: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <redis.client.PubSub object at 0x00000213B26AC198>\nargs = [b'celery-task-meta-2fddb8fe-e872-4a73-ad78-6218c609c79b'], kwargs = {}\nnew_channels = {b'celery-task-meta-2fddb8fe-e872-4a73-ad78-6218c609c79b': None}\n\n    def subscribe(self, *args, **kwargs):\n        \"\"\"\n        Subscribe to channels. Channels supplied as keyword arguments expect\n        a channel name as the key and a callable as the value. A channel's\n        callable will be invoked automatically when a message is received on\n        that channel rather than producing a message via ``listen()`` or\n        ``get_message()``.\n        \"\"\"\n        if args:\n            args = list_or_args(args[0], args[1:])\n        new_channels = dict.fromkeys(args)\n        new_channels.update(kwargs)\n>       ret_val = self.execute_command('SUBSCRIBE', *iterkeys(new_channels))\n\nC:\\Users\\luban\\AppData\\Local\\Programs\\Python\\Python37\\lib\\site-packages\\redis\\client.py:3580: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <redis.client.PubSub object at 0x00000213B26AC198>\nargs = ('SUBSCRIBE', b'celery-task-meta-2fddb8fe-e872-4a73-ad78-6218c609c79b')\n\n    def execute_command(self, *args):\n        \"Execute a publish/subscribe command\"\n    \n        # NOTE: don't parse the response in this function -- it could pull a\n        # legitimate message off the stack if the connection is already\n        # subscribed to one or more channels\n    \n        if self.connection is None:\n            self.connection = self.connection_pool.get_connection(\n                'pubsub',\n>               self.shard_hint\n            )\n\nC:\\Users\\luban\\AppData\\Local\\Programs\\Python\\Python37\\lib\\site-packages\\redis\\client.py:3468: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = ConnectionPool<Connection<host=127.0.0.1,port=6379,db=0>>\ncommand_name = 'pubsub', keys = (None,), options = {}\nconnection = Connection<host=127.0.0.1,port=6379,db=0>\n\n    def get_connection(self, command_name, *keys, **options):\n        \"Get a connection from the pool\"\n        self._checkpid()\n        with self._lock:\n            try:\n                connection = self._available_connections.pop()\n            except IndexError:\n                connection = self.make_connection()\n            self._in_use_connections.add(connection)\n    \n        try:\n            # ensure this connection is connected to Redis\n>           connection.connect()\n\nC:\\Users\\luban\\AppData\\Local\\Programs\\Python\\Python37\\lib\\site-packages\\redis\\connection.py:1192: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Connection<host=127.0.0.1,port=6379,db=0>\n\n    def connect(self):\n        \"Connects to the Redis server if not already connected\"\n        if self._sock:\n            return\n        try:\n            sock = self._connect()\n        except socket.timeout:\n            raise TimeoutError(\"Timeout connecting to server\")\n        except socket.error as e:\n>           raise ConnectionError(self._error_message(e))\nE           redis.exceptions.ConnectionError: Error 10061 connecting to 127.0.0.1:6379. 由于目标计算机积极拒绝，无法连接。.\n\nC:\\Users\\luban\\AppData\\Local\\Programs\\Python\\Python37\\lib\\site-packages\\redis\\connection.py:563: ConnectionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = Connection<host=127.0.0.1,port=6379,db=0>\n\n    def connect(self):\n        \"Connects to the Redis server if not already connected\"\n        if self._sock:\n            return\n        try:\n>           sock = self._connect()\n\nC:\\Users\\luban\\AppData\\Local\\Programs\\Python\\Python37\\lib\\site-packages\\redis\\connection.py:559: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Connection<host=127.0.0.1,port=6379,db=0>\n\n    def _connect(self):\n        \"Create a TCP socket connection\"\n        # we want to mimic what socket.create_connection does to support\n        # ipv4/ipv6, but we want to set options prior to calling\n        # socket.connect()\n        err = None\n        for res in socket.getaddrinfo(self.host, self.port, self.socket_type,\n                                      socket.SOCK_STREAM):\n            family, socktype, proto, canonname, socket_address = res\n            sock = None\n            try:\n                sock = socket.socket(family, socktype, proto)\n                # TCP_NODELAY\n                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n    \n                # TCP_KEEPALIVE\n                if self.socket_keepalive:\n                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n                    for k, v in iteritems(self.socket_keepalive_options):\n                        sock.setsockopt(socket.IPPROTO_TCP, k, v)\n    \n                # set the socket_connect_timeout before we connect\n                sock.settimeout(self.socket_connect_timeout)\n    \n                # connect\n                sock.connect(socket_address)\n    \n                # set the socket_timeout now that we're connected\n                sock.settimeout(self.socket_timeout)\n                return sock\n    \n            except socket.error as _:\n                err = _\n                if sock is not None:\n                    sock.close()\n    \n        if err is not None:\n>           raise err\n\nC:\\Users\\luban\\AppData\\Local\\Programs\\Python\\Python37\\lib\\site-packages\\redis\\connection.py:615: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Connection<host=127.0.0.1,port=6379,db=0>\n\n    def _connect(self):\n        \"Create a TCP socket connection\"\n        # we want to mimic what socket.create_connection does to support\n        # ipv4/ipv6, but we want to set options prior to calling\n        # socket.connect()\n        err = None\n        for res in socket.getaddrinfo(self.host, self.port, self.socket_type,\n                                      socket.SOCK_STREAM):\n            family, socktype, proto, canonname, socket_address = res\n            sock = None\n            try:\n                sock = socket.socket(family, socktype, proto)\n                # TCP_NODELAY\n                sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n    \n                # TCP_KEEPALIVE\n                if self.socket_keepalive:\n                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n                    for k, v in iteritems(self.socket_keepalive_options):\n                        sock.setsockopt(socket.IPPROTO_TCP, k, v)\n    \n                # set the socket_connect_timeout before we connect\n                sock.settimeout(self.socket_connect_timeout)\n    \n                # connect\n>               sock.connect(socket_address)\nE               ConnectionRefusedError: [WinError 10061] 由于目标计算机积极拒绝，无法连接。\n\nC:\\Users\\luban\\AppData\\Local\\Programs\\Python\\Python37\\lib\\site-packages\\redis\\connection.py:603: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <Connection: redis://127.0.0.1:6379// at 0x213b266a668>\nConnectionError = <class 'kombu.exceptions.OperationalError'>\nChannelError = <class 'kombu.exceptions.OperationalError'>\n\n    @contextmanager\n    def _reraise_as_library_errors(\n            self,\n            ConnectionError=exceptions.OperationalError,\n            ChannelError=exceptions.OperationalError):\n        try:\n>           yield\n\nC:\\Users\\luban\\AppData\\Local\\Programs\\Python\\Python37\\lib\\site-packages\\kombu\\connection.py:448: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <Celery tasks at 0x213b1005358>\nname = 'basic_frame.tasks.execute_command', args = (), kwargs = {}\ncountdown = None, eta = None, task_id = '2fddb8fe-e872-4a73-ad78-6218c609c79b'\nproducer = None, connection = None\nrouter = <celery.app.routes.Router object at 0x00000213B25F1390>\nresult_cls = <bound method Task.AsyncResult of <@task: basic_frame.tasks.execute_command of tasks at 0x213b1005358>>\nexpires = None, publisher = None, link = None, link_error = None\nadd_to_parent = True, group_id = None, group_index = None, retries = 0\nchord = None, reply_to = None, time_limit = None, soft_time_limit = None\nroot_id = None, parent_id = None, route_name = None, shadow = None, chain = None\ntask_type = <@task: basic_frame.tasks.execute_command of tasks at 0x213b1005358>\noptions = {'queue': <unbound Queue celery -> <unbound Exchange celery(direct)> -> celery>, 'serializer': 'json'}\nparent = None, have_parent = None\namqp = <celery.app.amqp.AMQP object at 0x00000213B25D6198>\nconf = Settings({'BROKER_URL': 'redis://127.0.0.1:6379', 'deprecated_settings': {'CELERY_RESULT_BACKEND', 'CELERY_ACCEPT_CONT...age)s', 'CELERYD_TIMER': None, 'CELERYD_TIMER_PRECISION': 1.0, 'deprecated_settings': None, 'CELERY_ENABLE_UTC': True})\nignored_result = False\nmessage = task_message(headers={'lang': 'py', 'task': 'basic_frame.tasks.execute_command', 'id': '2fddb8fe-e872-4a73-ad78-6218c6...c2-1873239c40af'}, body=((), {}, {'callbacks': None, 'errbacks': None, 'chain': None, 'chord': None}), sent_event=None)\nP = <Producer: None>\n\n    def send_task(self, name, args=None, kwargs=None, countdown=None,\n                  eta=None, task_id=None, producer=None, connection=None,\n                  router=None, result_cls=None, expires=None,\n                  publisher=None, link=None, link_error=None,\n                  add_to_parent=True, group_id=None, group_index=None,\n                  retries=0, chord=None,\n                  reply_to=None, time_limit=None, soft_time_limit=None,\n                  root_id=None, parent_id=None, route_name=None,\n                  shadow=None, chain=None, task_type=None, **options):\n        \"\"\"Send task by name.\n    \n        Supports the same arguments as :meth:`@-Task.apply_async`.\n    \n        Arguments:\n            name (str): Name of task to call (e.g., `\"tasks.add\"`).\n            result_cls (AsyncResult): Specify custom result class.\n        \"\"\"\n        parent = have_parent = None\n        amqp = self.amqp\n        task_id = task_id or uuid()\n        producer = producer or publisher  # XXX compat\n        router = router or amqp.router\n        conf = self.conf\n        if conf.task_always_eager:  # pragma: no cover\n            warnings.warn(AlwaysEagerIgnored(\n                'task_always_eager has no effect on send_task',\n            ), stacklevel=2)\n    \n        ignored_result = options.pop('ignore_result', False)\n        options = router.route(\n            options, route_name or name, args, kwargs, task_type)\n    \n        if not root_id or not parent_id:\n            parent = self.current_worker_task\n            if parent:\n                if not root_id:\n                    root_id = parent.request.root_id or parent.request.id\n                if not parent_id:\n                    parent_id = parent.request.id\n    \n                if conf.task_inherit_parent_priority:\n                    options.setdefault('priority',\n                                       parent.request.delivery_info.get('priority'))\n    \n        message = amqp.create_task_message(\n            task_id, name, args, kwargs, countdown, eta, group_id, group_index,\n            expires, retries, chord,\n            maybe_list(link), maybe_list(link_error),\n            reply_to or self.thread_oid, time_limit, soft_time_limit,\n            self.conf.task_send_sent_event,\n            root_id, parent_id, shadow, chain,\n            argsrepr=options.get('argsrepr'),\n            kwargsrepr=options.get('kwargsrepr'),\n        )\n    \n        if connection:\n            producer = amqp.Producer(connection, auto_declare=False)\n    \n        with self.producer_or_acquire(producer) as P:\n            with P.connection._reraise_as_library_errors():\n                if not ignored_result:\n>                   self.backend.on_task_call(P, task_id)\n\nC:\\Users\\luban\\AppData\\Local\\Programs\\Python\\Python37\\lib\\site-packages\\celery\\app\\base.py:748: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <celery.backends.redis.RedisBackend object at 0x00000213B266A710>\nproducer = <Producer: None>, task_id = '2fddb8fe-e872-4a73-ad78-6218c609c79b'\n\n    def on_task_call(self, producer, task_id):\n        if not task_join_will_block():\n>           self.result_consumer.consume_from(task_id)\n\nC:\\Users\\luban\\AppData\\Local\\Programs\\Python\\Python37\\lib\\site-packages\\celery\\backends\\redis.py:343: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <celery.backends.redis.ResultConsumer object at 0x00000213B26A1C50>\ntask_id = '2fddb8fe-e872-4a73-ad78-6218c609c79b'\n\n    def consume_from(self, task_id):\n        if self._pubsub is None:\n>           return self.start(task_id)\n\nC:\\Users\\luban\\AppData\\Local\\Programs\\Python\\Python37\\lib\\site-packages\\celery\\backends\\redis.py:159: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <celery.backends.redis.ResultConsumer object at 0x00000213B26A1C50>\ninitial_task_id = '2fddb8fe-e872-4a73-ad78-6218c609c79b', kwargs = {}\n\n    def start(self, initial_task_id, **kwargs):\n        self._pubsub = self.backend.client.pubsub(\n            ignore_subscribe_messages=True,\n        )\n>       self._consume_from(initial_task_id)\n\nC:\\Users\\luban\\AppData\\Local\\Programs\\Python\\Python37\\lib\\site-packages\\celery\\backends\\redis.py:137: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <celery.backends.redis.ResultConsumer object at 0x00000213B26A1C50>\ntask_id = '2fddb8fe-e872-4a73-ad78-6218c609c79b'\n\n    def _consume_from(self, task_id):\n        key = self._get_key_for_task(task_id)\n        if key not in self.subscribed_to:\n            self.subscribed_to.add(key)\n            with self.reconnect_on_error():\n>               self._pubsub.subscribe(key)\n\nC:\\Users\\luban\\AppData\\Local\\Programs\\Python\\Python37\\lib\\site-packages\\celery\\backends\\redis.py:167: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <contextlib._GeneratorContextManager object at 0x00000213B26B14E0>\ntype = <class 'redis.exceptions.ConnectionError'>\nvalue = ConnectionError('Error 10061 connecting to 127.0.0.1:6379. 由于目标计算机积极拒绝，无法连接。.')\ntraceback = <traceback object at 0x00000213B26B2C08>\n\n    def __exit__(self, type, value, traceback):\n        if type is None:\n            try:\n                next(self.gen)\n            except StopIteration:\n                return False\n            else:\n                raise RuntimeError(\"generator didn't stop\")\n        else:\n            if value is None:\n                # Need to force instantiation so we can reliably\n                # tell if we get the same exception back\n                value = type()\n            try:\n>               self.gen.throw(type, value, traceback)\n\nC:\\Users\\luban\\AppData\\Local\\Programs\\Python\\Python37\\lib\\contextlib.py:130: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <celery.backends.redis.ResultConsumer object at 0x00000213B26A1C50>\n\n    @contextmanager\n    def reconnect_on_error(self):\n        try:\n            yield\n        except self._connection_errors:\n            try:\n>               self._ensure(self._reconnect_pubsub, ())\n\nC:\\Users\\luban\\AppData\\Local\\Programs\\Python\\Python37\\lib\\site-packages\\celery\\backends\\redis.py:120: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <celery.backends.redis.RedisBackend object at 0x00000213B266A710>\nfun = <bound method ResultConsumer._reconnect_pubsub of <celery.backends.redis.ResultConsumer object at 0x00000213B26A1C50>>\nargs = (), policy = {}\nretry_policy = {'interval_max': 1, 'interval_start': 0, 'interval_step': 1, 'max_retries': 20}\nmax_retries = 20\n\n    def ensure(self, fun, args, **policy):\n        retry_policy = dict(self.retry_policy, **policy)\n        max_retries = retry_policy.get('max_retries')\n        return retry_over_time(\n            fun, self.connection_errors, args, {},\n            partial(self.on_connection_error, max_retries),\n>           **retry_policy)\n\nC:\\Users\\luban\\AppData\\Local\\Programs\\Python\\Python37\\lib\\site-packages\\celery\\backends\\redis.py:357: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nfun = <bound method ResultConsumer._reconnect_pubsub of <celery.backends.redis.ResultConsumer object at 0x00000213B26A1C50>>\ncatch = (<class 'amqp.exceptions.ConnectionError'>, <class 'kombu.exceptions.InconsistencyError'>, <class 'OSError'>, <class 'OSError'>, <class 'OSError'>, <class 'redis.exceptions.ConnectionError'>, ...)\nargs = [], kwargs = {}\nerrback = functools.partial(<bound method RedisBackend.on_connection_error of <celery.backends.redis.RedisBackend object at 0x00000213B266A710>>, 20)\nmax_retries = 20, interval_start = 0, interval_step = 1, interval_max = 1\ncallback = None, timeout = None\n\n    def retry_over_time(fun, catch, args=None, kwargs=None, errback=None,\n                        max_retries=None, interval_start=2, interval_step=2,\n                        interval_max=30, callback=None, timeout=None):\n        \"\"\"Retry the function over and over until max retries is exceeded.\n    \n        For each retry we sleep a for a while before we try again, this interval\n        is increased for every retry until the max seconds is reached.\n    \n        Arguments:\n            fun (Callable): The function to try\n            catch (Tuple[BaseException]): Exceptions to catch, can be either\n                tuple or a single exception class.\n    \n        Keyword Arguments:\n            args (Tuple): Positional arguments passed on to the function.\n            kwargs (Dict): Keyword arguments passed on to the function.\n            errback (Callable): Callback for when an exception in ``catch``\n                is raised.  The callback must take three arguments:\n                ``exc``, ``interval_range`` and ``retries``, where ``exc``\n                is the exception instance, ``interval_range`` is an iterator\n                which return the time in seconds to sleep next, and ``retries``\n                is the number of previous retries.\n            max_retries (int): Maximum number of retries before we give up.\n                If neither of this and timeout is set, we will retry forever.\n                If one of this and timeout is reached, stop.\n            interval_start (float): How long (in seconds) we start sleeping\n                between retries.\n            interval_step (float): By how much the interval is increased for\n                each retry.\n            interval_max (float): Maximum number of seconds to sleep\n                between retries.\n            timeout (int): Maximum seconds waiting before we give up.\n        \"\"\"\n        kwargs = {} if not kwargs else kwargs\n        args = [] if not args else args\n        interval_range = fxrange(interval_start,\n                                 interval_max + interval_start,\n                                 interval_step, repeatlast=True)\n        end = time() + timeout if timeout else None\n        for retries in count():\n            try:\n>               return fun(*args, **kwargs)\n\nC:\\Users\\luban\\AppData\\Local\\Programs\\Python\\Python37\\lib\\site-packages\\kombu\\utils\\functional.py:325: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <celery.backends.redis.ResultConsumer object at 0x00000213B26A1C50>\n\n    def _reconnect_pubsub(self):\n        self._pubsub = None\n        self.backend.client.connection_pool.reset()\n        # task state might have changed when the connection was down so we\n        # retrieve meta for all subscribed tasks before going into pubsub mode\n>       metas = self.backend.client.mget(self.subscribed_to)\n\nC:\\Users\\luban\\AppData\\Local\\Programs\\Python\\Python37\\lib\\site-packages\\celery\\backends\\redis.py:105: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Redis<ConnectionPool<Connection<host=127.0.0.1,port=6379,db=0>>>\nkeys = {b'celery-task-meta-2fddb8fe-e872-4a73-ad78-6218c609c79b'}\nargs = [b'celery-task-meta-2fddb8fe-e872-4a73-ad78-6218c609c79b'], options = {}\n\n    def mget(self, keys, *args):\n        \"\"\"\n        Returns a list of values ordered identically to ``keys``\n        \"\"\"\n        args = list_or_args(keys, args)\n        options = {}\n        if not args:\n            options[EMPTY_RESPONSE] = []\n>       return self.execute_command('MGET', *args, **options)\n\nC:\\Users\\luban\\AppData\\Local\\Programs\\Python\\Python37\\lib\\site-packages\\redis\\client.py:1671: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Redis<ConnectionPool<Connection<host=127.0.0.1,port=6379,db=0>>>\nargs = ('MGET', b'celery-task-meta-2fddb8fe-e872-4a73-ad78-6218c609c79b')\noptions = {}, pool = ConnectionPool<Connection<host=127.0.0.1,port=6379,db=0>>\ncommand_name = 'MGET'\n\n    def execute_command(self, *args, **options):\n        \"Execute a command and return a parsed response\"\n        pool = self.connection_pool\n        command_name = args[0]\n>       conn = self.connection or pool.get_connection(command_name, **options)\n\nC:\\Users\\luban\\AppData\\Local\\Programs\\Python\\Python37\\lib\\site-packages\\redis\\client.py:898: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = ConnectionPool<Connection<host=127.0.0.1,port=6379,db=0>>\ncommand_name = 'MGET', keys = (), options = {}\nconnection = Connection<host=127.0.0.1,port=6379,db=0>\n\n    def get_connection(self, command_name, *keys, **options):\n        \"Get a connection from the pool\"\n        self._checkpid()\n        with self._lock:\n            try:\n                connection = self._available_connections.pop()\n            except IndexError:\n                connection = self.make_connection()\n            self._in_use_connections.add(connection)\n    \n        try:\n            # ensure this connection is connected to Redis\n>           connection.connect()\n\nC:\\Users\\luban\\AppData\\Local\\Programs\\Python\\Python37\\lib\\site-packages\\redis\\connection.py:1192: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = Connection<host=127.0.0.1,port=6379,db=0>\n\n    def connect(self):\n        \"Connects to the Redis server if not already connected\"\n        if self._sock:\n            return\n        try:\n            sock = self._connect()\n        except socket.timeout:\n            raise TimeoutError(\"Timeout connecting to server\")\n        except socket.error as e:\n>           raise ConnectionError(self._error_message(e))\nE           redis.exceptions.ConnectionError: Error 10061 connecting to 127.0.0.1:6379. 由于目标计算机积极拒绝，无法连接。.\n\nC:\\Users\\luban\\AppData\\Local\\Programs\\Python\\Python37\\lib\\site-packages\\redis\\connection.py:563: ConnectionError\n\nThe above exception was the direct cause of the following exception:\n\nself = <allure_commons._allure.fixture object at 0x00000213B255F710>, args = ()\nkwargs = {}\n\n    def __call__(self, *args, **kwargs):\n        self.parameters = func_parameters(self._fixture_function, *args, **kwargs)\n    \n        with self:\n>           return self._fixture_function(*args, **kwargs)\n\nC:\\Users\\luban\\AppData\\Local\\Programs\\Python\\Python37\\lib\\site-packages\\allure_commons\\_allure.py:200: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n..\\conftest.py:75: in fix_module\n    execute_command.delay()\nC:\\Users\\luban\\AppData\\Local\\Programs\\Python\\Python37\\lib\\site-packages\\celery\\app\\task.py:421: in delay\n    return self.apply_async(args, kwargs)\nC:\\Users\\luban\\AppData\\Local\\Programs\\Python\\Python37\\lib\\site-packages\\celery\\app\\task.py:565: in apply_async\n    **options\nC:\\Users\\luban\\AppData\\Local\\Programs\\Python\\Python37\\lib\\site-packages\\celery\\app\\base.py:749: in send_task\n    amqp.send_task_message(P, name, message, **options)\nC:\\Users\\luban\\AppData\\Local\\Programs\\Python\\Python37\\lib\\contextlib.py:130: in __exit__\n    self.gen.throw(type, value, traceback)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <Connection: redis://127.0.0.1:6379// at 0x213b266a668>\nConnectionError = <class 'kombu.exceptions.OperationalError'>\nChannelError = <class 'kombu.exceptions.OperationalError'>\n\n    @contextmanager\n    def _reraise_as_library_errors(\n            self,\n            ConnectionError=exceptions.OperationalError,\n            ChannelError=exceptions.OperationalError):\n        try:\n            yield\n        except (ConnectionError, ChannelError):\n            raise\n        except self.recoverable_connection_errors as exc:\n>           raise ConnectionError(str(exc)) from exc\nE           kombu.exceptions.OperationalError: Error 10061 connecting to 127.0.0.1:6379. 由于目标计算机积极拒绝，无法连接。.\n\nC:\\Users\\luban\\AppData\\Local\\Programs\\Python\\Python37\\lib\\site-packages\\kombu\\connection.py:452: OperationalError"}, "description": "\n         获取测试用例执行结果: 调用001\n        ", "steps": [{"name": "get_login_session", "status": "passed", "parameters": [{"name": "fix_login_session", "value": "'7964a5d6-69f5-42a2-9e24-61137821ce37'"}, {"name": "something", "value": "None"}], "start": 1619691140971, "stop": 1619691140971}], "attachments": [{"name": "log", "source": "543e2874-adb8-4d02-a49d-95346230852a-attachment.txt", "type": "text/plain"}], "start": 1619691140970, "stop": 1619691140971, "uuid": "30517a7c-3a00-4220-9bc2-da9edd6cfcd1", "historyId": "f2c25769b4c62f32b7b529da2bc05b4e", "testCaseId": "76c1349a3407b11b21b492be8f11ad74", "fullName": "basic_frame.cases.test_session.TestSession#test_login_session", "labels": [{"name": "severity", "value": "normal"}, {"name": "feature", "value": "get_after_get_login_session"}, {"name": "story", "value": "get_login_session"}, {"name": "tag", "value": "get_result"}, {"name": "parentSuite", "value": "basic_frame.cases"}, {"name": "suite", "value": "test_session"}, {"name": "subSuite", "value": "TestSession"}, {"name": "host", "value": "DESKTOP-H3U0RMV"}, {"name": "thread", "value": "6016-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "basic_frame.cases.test_session"}]}